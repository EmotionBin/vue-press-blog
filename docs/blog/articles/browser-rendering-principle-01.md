# 浏览器渲染原理

浏览器可以让我们看到各种各样的网页，那么浏览器肯定也有着自己的一套渲染网页的机制，作为一名合格的前端攻城狮，必须要对浏览器的渲染机制以及渲染原理有一个了解，这样会对我们的开发有着至关重要的作用，对页面的性能优化也有很大的帮助  

## 进程和线程

首先要了解操作系统中两个重要的概念，就是进程和线程  

**进程**是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）  

**线程**是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）  

对于操作系统来说，一个任务就是一个进程，在一个进程内部，要同时做多件事，就需要同时运行多个**子任务**，我们把进程内的这些子任务称为线程，所以**线程是跑在进程里面的**  

----

## 浏览器的多进程架构

就拿`Chrome`来说，`Chrome`是多进程的，每新开一个Chrome网页就相当于开启了一个新的进程，每个tab网页都是一个独立的进程  

多进程的优点：

- 单个 tab 页面崩溃不会影响到整个浏览器
- 第三方插件崩溃也不会影响到整个浏览器
- 多进程可以充分利用现代 CPU 多核的优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

多进程的缺点：

- 每个新开的进程都会分配CPU、内存等资源，对设备要求较高，资源消耗大

----

## 浏览器的主要进程

`Chrome`的每一个页面都是一个独立的进程，在这个独立的进程中又存在多个进程，浏览器的进程主要包括以下四部分：

1. 主进程：负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等
2. 第三方插件进程：每种类型的插件对应一个进程,仅当使用该插件时才创建
3. GPU进程：最多只有一个,用于 3D 绘制等
4. 渲染进程：称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等

![NSnb7T.png](https://s1.ax1x.com/2020/06/14/NSnb7T.png)

这些进程负责着浏览器运行时的各个角色，其中**渲染进程(也叫浏览器内核)**是重点  

----

## 浏览器渲染进程(浏览器内核)

`Chrome`的每一个页面都是一个独立的进程，在每个独立的进程下面，又会有不同的线程跑在这个进程中。渲染进程就是多线程的，它包括GUI渲染线程、JS引擎线程、事件触发线程、定时触发器线程、异步http请求线程  

![NSuOqP.png](https://s1.ax1x.com/2020/06/14/NSuOqP.png)

### GUI渲染线程

- 负责渲染浏览器界面,解析 `HTML` , `CSS` ,构建 `DOM` 树和 `RenderObject` 树,布局和绘制等
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行
- 注意,**GUI渲染线程与 JS 引擎线程是互斥的**,当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行

----

### JS 引擎线程

- `Javascript` 引擎,也称为 JS 内核,负责处理 `Javascript` 脚本程序（例如 V8 引擎）
- JS 引擎线程负责解析 `Javascript` 脚本,运行代码
- JS 引擎一直等待着任务队列中任务的到来,然后加以处理,一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
- 注意,**GUI 渲染线程与 JS 引擎线程是互斥的**,所以如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞

----

### 事件触发线程

- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当 JS 引擎执行代码块如 `setTimeOut` 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等）,会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

----

### 定时触发器线程

- 传说中的 `setInterval` 与 `setTimeout` 所在线程
- 浏览器定时计数器并不是由 `JavaScript` 引擎计数的,（因为 `JavaScript` 引擎是单线程的, 如果处于阻塞线程状态就会影响计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中,等待 JS 引擎空闲后执行）
- 注意,W3C 在 `HTML` 标准中规定,规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms

### 异步 http 请求线程

- `XMLHttpRequest` 在连接后是通过浏览器新开一个线程发起请求
- 将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中。再由 `JavaScript` 引擎执行

----

## 浏览器渲染过程

这张图是一张比较经典的图，它大致描述了浏览器渲染的主要过程：  

![NC4soQ.png](https://s1.ax1x.com/2020/06/15/NC4soQ.png)

浏览器在获取到文件后，渲染过程主要分为以下几个步骤：

1. 解析 `HTML` 文件,构建 `DOM` 树,同时浏览器主进程负责下载 `CSS` 文件
2. `CSS` 文件下载完成,解析 `CSS` 文件成树形的数据结构(`CSSOM`),然后结合 `DOM` 树合并成 `RenderObject` 树
3. 布局 `RenderObject` 树 （Layout/reflow）,负责 `RenderObject` 树中的元素的尺寸,位置等计算
4. 绘制 `RenderObject` 树 （paint）,绘制页面的像素信息
5. 浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面

----

## 关于浏览器渲染的细节

### 关键渲染路径

在浏览器拿到HTML、CSS、JS等外部资源到渲染出页面的过程，有一个重要的概念叫**关键渲染路径**，关键渲染路径是浏览器将 HTML 、CSS 、 JS 转换为在屏幕上呈现的像素内容所经历的一系列步骤  

----

#### HTML

HTML 文件会经过解析之后生成 `DOM Tree`，有了`DOM Tree`才能显示网页，所以HTML是必须的  

可以从以下方面优化HTML的渲染

- 在生产环境下，删除不必要的代码和注释包括空格,尽量做到最小化文件
- 可以利用 `GZIP` 压缩文件
- 结合 `HTTP` 缓存文件

----

#### CSS

**CSS是由单独的下载线程异步下载的**，所以浏览器可以一边下载CSS资源，一边进行 `DOM `解析构建。我们知道要想显示页面，必须要在生成渲染树(`Render Tree`)之后才能显示，而`Render Tree`又依赖于`DOM Tree`和`CSSOM Tree`，所以必须等待到 `CSSOM Tree` 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染  

综上所述， CSS 在关键渲染路径中有以下特点：

1. CSS 加载不会阻塞 `DOM` 的解析（异步加载时`DOM`照常构建）
2. CSS 加载会阻塞 `DOM` 的渲染（渲染时需等CSS加载完毕，因为`Render Tree`依赖于CSS）
3. CSS加载会阻塞后面JS语句的执行

----

#### JS

 JS 线程和 UI 渲染线程是互斥的，所以当脚本在执行的时候浏览器要将控制权交给 JS 线程，等到 JS 线程执行完毕再还给 UI 渲染线程，**不论这个脚本是以何种形式加载的，在执行时均会阻塞 UI 的渲染**  

只要浏览器遇到没有 `defer` 或 `async`标记的`script`标签，浏览器会立即唤醒`JavaScript`解析器，暂停解析HTML，如果将要执行脚本时浏览器尚未完成 `CSSOM` 的下载及构建，**浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建后，执行该脚本**  

**async:** 当我们在 `script` 标签添加 `async` 属性以后，浏览器遇到这个 `script` 标签时会继续解析 `DOM`，同时脚本也不会被 `CSSOM` 阻止，即不会阻止关键渲染路径  

**defer:** 与 `async` 的区别在于，脚本需要等到文档解析后（ `DOMContentLoaded` 事件前）执行，而 `async` 允许脚本在文档解析时位于后台运行  

带 `defer`或`async` 的脚本会与 HTML 并行下载，**下载的过程不会阻塞 DOM 的构建，但是执行是会的**  

综上所属，JS 在关键渲染路径中有以下特点：

1. JS会阻塞关键渲染路径
2. 带 `defer`或`async` 的脚本下载的过程不会阻塞 `DOM` 的构建，但是执行是会的

----

#### 关键渲染路径优化

可以从以下方面优化关键渲染路径：  

- 最小化关键资源数: 消除它们（内联）、推迟它们的下载（`defer`）或者使它们异步解析（`async`）等等
- 优化关键字节数（缩小、压缩）来减少下载时间
- 优化加载剩余关键资源的顺序: 让关键资源（CSS）尽早下载以减少关键渲染路径长度

----

### 回流和重绘

浏览器使用**流式布局模型**，渲染时对`Render Tree`的计算通常只需要遍历一次就可以完成(`table`及其内部元素除外)  

----

#### 回流

**回流(Reflow):**当页面中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程  

可能会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除可见的`DOM`元素
- 激活CSS伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

----

#### 重绘

**重绘(Repaint):**当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它的过程  

可能会导致重绘的操作：

- 改变元素的`color`
- 改变元素的`background-color`
- 改变元素的`visibility`

----

#### 性能影响

**回流必将引起重绘，重绘不一定会引起回流，回流比重绘的代价要更高**  

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流  

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次  

----

#### 如何避免

要想尽量避免回流和重绘，可以从CSS和JS入手  

CSS:  

- 避免使用`table`布局
- 尽可能在`DOM`树的最末端改变`class`
- 避免设置多层内联样式
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
- 避免使用CSS表达式（例如：`calc()`）

JS:  

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM`操作，最后再把它添加到文档中
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

----

### GUI渲染线程与JS引擎线程互斥

由于 JS 是可操纵 `DOM` 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了  

当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中，等到引擎线程空闲时立即被执行  

----

### 输入一个url按下回车后发生了什么

1. DNS解析
2. IP寻址
3. 通过三次握手建立TCP连接
4. TCP连接建立成功后，浏览器发送HTTP请求
5. 服务器响应数据
6. 浏览器收到数据，浏览器渲染进程开始渲染(具体过程可以参考本文的浏览器渲染过程，这里省略)

以上过程都是简述，如果要详细展开可以写很长很长...  

----

## 结束语

作为一名前端开发攻城狮，浏览器的渲染原理是必须要掌握和理解的，如果理解了会对性能优化方面有很大的帮助。如果本文中有说的不正确的地方，欢迎大佬鞭策!  

**参考资料：**

[浅析浏览器渲染原理](https://segmentfault.com/a/1190000012960187)  
[从 8 道面试题看浏览器渲染过程与性能优化](https://juejin.im/post/5e143104e51d45414a4715f7)  
[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)  
[浏览器的回流与重绘 (Reflow & Repaint)](https://juejin.im/post/5a9923e9518825558251c96a)  